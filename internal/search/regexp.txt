// s := fmt.Sprintf("%s[%s](%s)[%s]%s", ctxLinesString, string(delimiters), strings.Join(flagKeys, "|"), string(delimiters), ctxLinesString)
	// rgxp := regexp.MustCompile(s)
	// linesStr := strings.Join(f.lines, "\n")
	// matches := rgxp.FindAllStringSubmatchIndex(linesStr, -1)

	// s = fmt.Sprintf("%s(%s)%s", ctxLinesString, strings.Join(flattenedAliases, "|"), ctxLinesString)
	// rgxp = regexp.MustCompile(s)
	// aliasMatches := rgxp.FindAllStringSubmatchIndex(linesStr, -1)
	// matches = append(matches, aliasMatches...)

	// for _, loc := range matches {
	// 	contextStartIdx := loc[0]
	// 	contextEndIdx := loc[1]
	// 	flagKeyStartIdx := loc[2]
	// 	flagKeyEndIdx := loc[3]

	// 	context := strings.Split(linesStr[contextStartIdx:contextEndIdx], "\n")
	// 	context = context[:len(context)-1]

	// 	key := linesStr[flagKeyStartIdx:flagKeyEndIdx]
	// 	startingLineNum := strings.Count(linesStr[:contextStartIdx], "\n")

	// 	linesForMatch := make([]SearchResultLine, 0, len(context))
	// 	for i, line := range context {
	// 		srl := SearchResultLine{
	// 			Path:     f.path,
	// 			LineNum:  startingLineNum + i,
	// 			LineText: strings.TrimSuffix(line, "\n"),
	// 		}
	// 		if i == ctxLines {
	// 			flagKey := key
	// 			isAlias := false
	// 			_, ok := aliases[key]
	// 			if !ok {
	// 				flagKey = aliasToFlag[key]
	// 				isAlias = true
	// 			}
	// 			if srl.FlagKeys[flagKey] == nil {
	// 				srl.FlagKeys = map[string][]string{flagKey: {}}
	// 			}
	// 			if isAlias {
	// 				srl.FlagKeys[flagKey] = append(srl.FlagKeys[flagKey], key)
	// 			}
	// 		}
	// 		linesForMatch = append(linesForMatch, srl)
	// 	}
	// 	ret = append(ret, linesForMatch...)
	// }